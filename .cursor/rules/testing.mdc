---
description: Always use when writing new/modifying existing test files
globs: 
alwaysApply: false
---
# Requirements
- **ALWAYS run tests before finishing** any test-related work (writing new tests, modifying existing tests, refactoring test code)
- Use `pnpm test:coverage <test-file-path>` to run specific test files
- Fix any failures or TypeScript errors before completing the task
- Don't ask me to review the test without running it first and fixing any issues, including TypeScript errors!

## File Structure
- Test files should be named `*.test.ts` and placed in a `tests` directory on the same level as the file being tested
- Import statements can be placed anywhere relative to `vi.mock()` calls since `vi.mock()` is hoisted – prefer placing imports at the top for readability

## Test Organization
- Only use `describe` blocks when testing multiple distinct features/components in a single test file
- For single utility tests, use `it` blocks directly without wrapping them in `describe`
- When referencing code values in test names (variables, properties, etc.), wrap them in backticks
  - ✅ `it('should save play stats without `requestedById`')`
  - ❌ `it('should save play stats without requestedById')`

## Mocking
- **Never** mock simple utility functions (like `isObject`, `pluralize`, etc.) – let them run naturally in tests
- Only mock external dependencies and complex integrations that require specific context (like Discord.js, discord-player)
- **Never** use dynamic imports or `require` calls in tests – always use proper ES module imports at the top of the file
  - ❌ `new (require('discord.js').ButtonBuilder)()`
  - ✅ `import { ButtonBuilder } from 'discord.js'; ... new ButtonBuilder()`
- Mock primarily via `vi.mock(...)` and ensure all required classes/functions are properly imported
- Consult the `src/setupTests.ts` file and use it to define global mocks
- **Do not duplicate mocks** that are already defined globally in `src/setupTests.ts` (like logger, redis, Sentry, etc.)

## Coverage
- Aim for meaningful coverage that tests the core functionality, not arbitrary percentage targets
- Focus on testing:
  - Main execution paths and business logic
  - Error handling and edge cases
  - Public API behavior
- **Do not force 100% coverage** at the expense of test quality or maintainability
- Some code may be difficult to test in isolation (like singleton patterns, complex integrations) – focus on what can be reliably tested
- When coverage is low, consider if additional test cases would provide meaningful value before adding them

